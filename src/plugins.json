{"gamepad-notes":{"addSpeakerScripts":{"./plugins/gamepad-notes/gamepad.js":"let mapping = {};\n\nlet throttleTimer;\n\nconst throttle = (callback, time) => {\n  if (throttleTimer) return;\n  throttleTimer = true;\n  setTimeout(() => {\n    callback();\n    throttleTimer = false;\n  }, time);\n};\n\nconst buttonPressed = (b) => {\n  if (typeof b === \"object\") {\n    return b.pressed;\n  }\n  return b === 1.0;\n};\n\nconst gameLoop = () => {\n  const gamepads = navigator.getGamepads();\n  if (!gamepads) {\n    return;\n  }\n\n  const gp = gamepads[0];\n  for (let i = 0; i < 16; i += 1) {\n    if (buttonPressed(gp.buttons[i]) && mapping[i]) {\n      if (mapping[i].startsWith(\"notes\")) {\n        window.slidesk[mapping[i]]();\n      } else {\n        window.slidesk.io.send(JSON.stringify({ action: mapping[i] }));\n      }\n    }\n  }\n  requestAnimationFrame(() => throttle(gameLoop, 300));\n};\n\nconst fetchMapping = async () => {\n  try {\n    const response = await fetch(\"/mapping.json\");\n    const json = await response.json();\n    mapping = json;\n  } catch (erreur) {\n    mapping = {\n      15: \"next\",\n      14: \"previous\",\n      6: \"next\",\n      7: \"previous\",\n    };\n  }\n  window.addEventListener(\"gamepadconnected\", () => {\n    gameLoop();\n  });\n};\n\nfetchMapping();\n"}},"autonext":{"onSlideChange":"const classes = [...window.slidesk.slides[window.slidesk.currentSlide].classList].filter(c => c.startsWith('auto-')); if (classes.length) { const timer = Number(classes[0].replace('auto-', '')) + Number(window.slidesk.animationTimer); window.slidesk.autonext = setTimeout(() => window.slidesk.next(), timer); } else { clearTimeout(window.slidesk.autonext); }"},"gamepad":{"addScripts":{"./plugins/gamepad/gamepad.js":"let mapping = {};\n\nlet throttleTimer;\n\nconst throttle = (callback, time) => {\n  if (throttleTimer) return;\n  throttleTimer = true;\n  setTimeout(() => {\n    callback();\n    throttleTimer = false;\n  }, time);\n};\n\nconst buttonPressed = (b) => {\n  if (typeof b === \"object\") {\n    return b.pressed;\n  }\n  return b === 1.0;\n};\n\nconst gameLoop = () => {\n  const gamepads = navigator.getGamepads();\n  if (!gamepads) {\n    return;\n  }\n\n  const gp = gamepads[0];\n  for (let i = 0; i < 16; i += 1)\n    if (buttonPressed(gp.buttons[i]) && mapping[i]) {\n      switch (mapping[i]) {\n        case \"previous\":\n          window.slidesk.previous();\n          break;\n        case \"next\":\n          window.slidesk.next();\n          break;\n        default:\n          break;\n      }\n    }\n\n  requestAnimationFrame(() =>\n    throttle(gameLoop, window.slidesk.animationTimer),\n  );\n};\n\nconst fetchMapping = async () => {\n  try {\n    const response = await fetch(\"/mapping.json\");\n    const json = await response.json();\n    mapping = json;\n  } catch (erreur) {\n    mapping = {\n      15: \"next\",\n      14: \"previous\",\n      6: \"next\",\n      7: \"previous\",\n    };\n  }\n  window.addEventListener(\"gamepadconnected\", () => {\n    gameLoop();\n  });\n};\n\nfetchMapping();\n"}},"source":{"addHTML":"<button id=\"sd-showSource\" popovertarget=\"sd-source\">&lt;/&gt;</button><div id=\"sd-source\" popover><pre>x</pre></div>","onSlideChange":"window.slidesk.changeSource();","addScripts":{"./plugins/source/source.js":"const fromBinary = (encoded) => {\n  const binary = atob(encoded);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < bytes.length; i += 1) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return String.fromCharCode(...new Uint16Array(bytes.buffer));\n};\n\nconst supportsPopover = () => HTMLElement.prototype.hasOwnProperty(\"popover\");\n\nwindow.slidesk.changeSource = () => {\n  if (supportsPopover())\n    document.querySelector(\"#sd-source pre\").innerText = fromBinary(\n      window.slidesk.slides[window.slidesk.currentSlide].getAttribute(\n        \"data-source\",\n      ),\n    );\n};\n\nif (!supportsPopover()) {\n  document.querySelector(\"#sd-showSource\").style.display = \"none\";\n  document.querySelector(\"#sd-source\").style.display = \"none\";\n}\n"},"addStyles":{"./plugins/source/source.css":"#sd-showSource {\n  position: absolute;\n  bottom: 10px;\n  right: 10px;\n  background-color: var(--sd-text-color);\n  padding: 5px;\n  color: var(--sd-background-color);\n  text-decoration: none;\n  border-radius: 5px;\n  font-size: 1rem;\n}\n\n#sd-showSource:hover {\n  cursor: pointer;\n}\n\n#sd-source {\n  background-color: var(--sd-background-color);\n  color: var(--sd-text-color);\n  padding: 10px 20px;\n  margin: auto;\n}\n"}},"qrcode":{"addHTML":"<div id=\"sd-qrcode\">&nbsp;</div>","onSlideChange":"window.slidesk.qrcode();","addScripts":{"./plugins/qrcode/qrcode.lib.js":"let chunkString = (content, length) =>\n  range0(Math.ceil(len(content) / length)).map((i) =>\n    content.substr(i++ * length, length),\n  );\nlet pad0 = (count, content = \"\") => content.padStart(count, \"0\");\nlet numToBits = (content, count) => pad0(count, content.toString(2));\nlet bitsToArray = (bits) => [...bits].map(Number);\nlet range = (from, to) => Array.from({ length: to - from }, (_, i) => i + from);\nlet range0 = (to) => range(0, to);\nlet createMatrix = (dimensions) => {\n  let base = range0(dimensions).map((_) => null);\n  return base.map((_) => base.slice());\n};\nlet cloneMatrix = (matrix) => matrix.slice().map((m) => m.slice());\nlet len = (array) => array.length;\nlet mergeMatrices = (matrix1, matrix2) => {\n  let result2 = cloneMatrix(matrix1);\n  iterateOverMatrix(\n    matrix1,\n    (val, x, y) => val === null && (result2[y][x] = matrix2[y][x]),\n  );\n  return result2;\n};\nlet iterateOverMatrix = (matrix, fn, fnSecondary = () => {}, direction = 0) => {\n  matrix.map(\n    (row, y) => (\n      row.map((val, x) =>\n        direction === 0\n          ? fn(val, x, y, matrix)\n          : fn(matrix[x][y], y, x, matrix),\n      ),\n      fnSecondary(y, matrix)\n    ),\n  );\n};\nlet encodeUtf8 = (s) => {\n  let ci = 0,\n    bytes = [],\n    c;\n  for (; ci < len(s); ci++) {\n    if ((c = s.charCodeAt(ci)) < 128 && bytes.push(c)) continue;\n    if (c < 2048) bytes.push((c >> 6) | 192);\n    else {\n      if (c > 55295 && c < 56320) {\n        c = 65536 + ((c & 1023) << 10) + (s.charCodeAt(++ci) & 1023);\n        bytes.push((c >> 18) | 240, ((c >> 12) & 63) | 128);\n      } else bytes.push((c >> 12) | 224);\n      bytes.push(((c >> 6) & 63) | 128);\n    }\n    bytes.push((c & 63) | 128);\n  }\n  return bytes;\n};\nvar EcLevels = /* @__PURE__ */ ((EcLevels2) => {\n  EcLevels2[(EcLevels2[\"L\"] = 0)] = \"L\";\n  EcLevels2[(EcLevels2[\"M\"] = 1)] = \"M\";\n  EcLevels2[(EcLevels2[\"Q\"] = 2)] = \"Q\";\n  EcLevels2[(EcLevels2[\"H\"] = 3)] = \"H\";\n  return EcLevels2;\n})(EcLevels || {});\nlet qrDefinitionTable = chunkString(\n  \"0011030906060a020325091a14141a0908441834100a1406126710231816090218921633100814041056091916111a0812651022100718061682142914101807219a1427120916051056183316111a081268213a1a1416051678142718121a0718911428161214042199163012091605147316312116160516831a35161121081a911a361a141a0721a318331a141a071a971834181318061a91183121161a081a9a18321a1421091a951a362116160621a41a372116210821a01a352116210918901a37211621081a981a361a14210921a51a352115210821a01a3521162108219a1a352115210821991a372116210821991a362116210821991a362116210821991a362116210821991a362116210921a41a372116210821a41a372116210821a51a362116210821a51a362116210821a01a372116210821a11a3721162108\",\n  2,\n).map((s) => parseInt(s, 11) + 7);\nlet getDimensions = (version) => 17 + 4 * version;\nlet getSupportedBits = (version) => {\n  let dimensions = getDimensions(version);\n  let alignmentElementsDimensions = 2 + (0 | (version / 7));\n  let alignmentModules =\n    (5 * alignmentElementsDimensions - 1) *\n      (5 * alignmentElementsDimensions - 1) -\n    56;\n  return (\n    -191 -\n    2 * dimensions +\n    dimensions * dimensions -\n    alignmentModules * +(version > 1) -\n    36 * +(version > 6)\n  );\n};\nlet getRemainderBits = (version) => getSupportedBits(version) % 8;\nlet getAlignmentPattern = (version) => {\n  let last = 4 + 4 * version;\n  let elements = 0 | (version / 7);\n  let startStep = 0 | (last / (elements + 1));\n  let firstStep = startStep;\n  let nextStep = firstStep;\n  if (elements > 1) {\n    nextStep = 2 * Math.ceil(((last - startStep) / elements + 1e-4) / 2);\n    firstStep = last - nextStep * elements;\n  }\n  return version < 2\n    ? []\n    : [6, ...range0(elements + 1).map((i) => 6 + firstStep + i * nextStep)];\n};\nlet getGroups = (version, ecLevel) => {\n  let index = version * 8 - 8 + ecLevel * 2,\n    ecPerBlock = qrDefinitionTable[index],\n    wordsPerBlock = qrDefinitionTable[++index],\n    bytes = 0 | (getSupportedBits(version) / 8),\n    y = 0,\n    x = 0,\n    sumBlock = ecPerBlock + wordsPerBlock;\n  for (; x < 57; x++)\n    if ((y = (bytes - sumBlock * x) / (sumBlock + 1)) % 1 === 0) break;\n  let result2 = [{ blocks: x, wordsPerBlock, ecPerBlock }];\n  y > 0 && wordsPerBlock++;\n  result2.push({ blocks: y, wordsPerBlock, ecPerBlock });\n  return result2;\n};\nlet getChracterCountBits = (version) => (version <= 9 ? 8 : 16);\nlet getRequiredNumberOfBits = (groups2) =>\n  groups2.reduce((acc, val) => acc + val.wordsPerBlock * val.blocks, 0) * 8;\nlet versionLookup = [];\nlet requiredNumberOfBits, characterCountBits, groups;\nrange(1, 41).map((version) => {\n  range0(4).map((ecLevel) => {\n    groups = getGroups(version, ecLevel);\n    requiredNumberOfBits = getRequiredNumberOfBits(groups);\n    characterCountBits = getChracterCountBits(version);\n    versionLookup.push({\n      ecLevel,\n      version,\n      groups,\n      requiredNumberOfBits,\n      characterCountBits,\n      upperLimit: 0 | ((requiredNumberOfBits - (4 + characterCountBits)) / 8),\n      remainderBits: getRemainderBits(version),\n      dimensions: getDimensions(version),\n      alignmentPattern: getAlignmentPattern(version),\n    });\n  });\n});\nlet getSmallestVersion = (length, ecLevel) => {\n  let lookup = versionLookup.filter(\n    (v) => v.ecLevel === ecLevel && v.upperLimit >= length,\n  );\n  if (!lookup) throw new Error(\"Input too long!\");\n  return lookup[0];\n};\nlet getParameters = (content, ecLevel) =>\n  getSmallestVersion(len(encodeUtf8(content)), ecLevel);\nlet score = 0;\nlet getLineGroupScore = (matrix) => {\n  let currentColor = false;\n  let currentRun = 0;\n  let scoreLineGroupCondition = () => {\n    score += currentRun >= 5 ? currentRun - 2 : 0;\n    currentRun = 0;\n  };\n  [0, 1].map((dir) => {\n    iterateOverMatrix(\n      matrix,\n      (value) => {\n        if (value !== currentColor) {\n          scoreLineGroupCondition();\n          currentColor = value;\n        }\n        currentRun++;\n      },\n      scoreLineGroupCondition,\n      dir,\n    );\n  });\n};\nlet getSquareScore = (matrix) => {\n  iterateOverMatrix(matrix, (_, x, y) => {\n    if (x < len(matrix) - 1 && y < len(matrix) - 1) {\n      let squareBitMask = range0(4).reduce(\n        (acc, dirBitMask, i) =>\n          acc | (+matrix[y + (dirBitMask >> 1)][x + (dirBitMask & 1)] << i),\n        0,\n      );\n      score += squareBitMask % 15 === 0 ? 3 : 0;\n    }\n  });\n};\nlet getFinderConfusionScore = (matrix) => {\n  let patterns = [\n    { template: bitsToArray(\"10111010000\"), current: 0 },\n    { template: bitsToArray(\"00001011101\"), current: 0 },\n  ];\n  [0, 1].map((dir) => {\n    iterateOverMatrix(\n      matrix,\n      (value) =>\n        patterns.map((pattern) => {\n          pattern.current +=\n            +value === pattern.template[pattern.current] ? 1 : -pattern.current;\n          if (pattern.current >= len(pattern.template)) {\n            score += 40;\n            pattern.current = 0;\n          }\n        }),\n      () => patterns.map((pattern) => (pattern.current = 0)),\n      dir,\n    );\n  });\n};\nlet getColorImbalanceScore = (matrix) => {\n  let darkCount = 0;\n  iterateOverMatrix(matrix, (value) => (darkCount += +value));\n  let percentage = +((darkCount / (len(matrix) * len(matrix))) * 100);\n  let lower = percentage - (percentage & 5);\n  score +=\n    Math.min(...[lower, lower + 5].map((el) => Math.abs(el - 50) / 5)) * 10 + 5;\n};\nlet maskingMethods = [\n  (x, y) => (x + y) % 2,\n  (x, y) => y % 2,\n  (x) => x % 3,\n  (x, y) => (x + y) % 3,\n  (x, y) => (0 | (y / 2 + (0 | (x / 3)))) % 2,\n  (x, y) => ((x * y) % 2) + ((x * y) % 3),\n  (x, y) => (((x * y) % 2) + ((x * y) % 3)) % 2,\n  (x, y) => (((x + y) % 2) + ((x * y) % 3)) % 2,\n];\nlet evaluateMasking = (matrix) => (\n  (score = 0),\n  getLineGroupScore(matrix),\n  getSquareScore(matrix),\n  getFinderConfusionScore(matrix),\n  getColorImbalanceScore(matrix)\n);\nlet maskMatrix = (matrix, condition) => {\n  let copy = cloneMatrix(matrix);\n  iterateOverMatrix(copy, (value, x, y) =>\n    !condition(x, y) ? (copy[y][x] = !value) : 0,\n  );\n  return copy;\n};\nlet applyMasking = (patternMatrix, dataMatrix) =>\n  maskingMethods\n    .map((method) =>\n      mergeMatrices(patternMatrix, maskMatrix(dataMatrix, method)),\n    )\n    .reduce(\n      (acc, matrix, mask) => (\n        evaluateMasking(matrix),\n        score < acc.score ? { score, mask, matrix } : acc\n      ),\n      {\n        score: 1 << 30,\n        mask: 0,\n        matrix: [],\n      },\n    );\nlet applyFinderPatterns = (matrix) => {\n  let dimensions = len(matrix);\n  let dimensionsSubSeven = dimensions - 7;\n  let drawSquares = (x, y) => {\n    matrix[y + 3][x + 3] = true;\n    range0(3).map((j) => {\n      range(j, 7 - j).map(\n        (i) =>\n          (matrix[y + j][x + i] =\n            matrix[y + 6 - j][x + i] =\n            matrix[y + i][x + j] =\n            matrix[y + i][x + 6 - j] =\n              j % 2 === 0),\n      );\n    });\n  };\n  range0(8).map(\n    (i) =>\n      (matrix[i][7] =\n        matrix[7][i] =\n        matrix[7][dimensions - i - 1] =\n        matrix[dimensions - i - 1][7] =\n        matrix[dimensionsSubSeven - 1][i] =\n        matrix[i][dimensionsSubSeven - 1] =\n          false),\n  );\n  drawSquares(0, 0);\n  drawSquares(0, dimensionsSubSeven);\n  drawSquares(dimensionsSubSeven, 0);\n};\nlet applyTimingPatterns = (matrix) =>\n  range(7, len(matrix) - 7).map(\n    (i) => (matrix[6][i] = matrix[i][6] = i % 2 === 0),\n  );\nlet applyDarkModule = (matrix) => (matrix[matrix.length - 8][8] = true);\nlet applyReservedAreas = (matrix, version) => {\n  let dimensions = len(matrix);\n  [range0(9), range(dimensions - 8, dimensions)]\n    .flat()\n    .map((i) => (matrix[i][8] = matrix[8][i] = false));\n  if (version >= 7)\n    range0(3).map((i) =>\n      range0(6).map(\n        (j) =>\n          (matrix[dimensions - 11 + i][j] = matrix[j][dimensions - 11 + i] =\n            false),\n      ),\n    );\n};\nlet applyAlignmentPatterns = (matrix, locations) =>\n  locations.map((x, i) =>\n    locations\n      .slice(\n        +(i === 0 || i === len(locations) - 1),\n        i > 0 ? len(locations) : -1,\n      )\n      .map((y) =>\n        range0(3).map((j) =>\n          range(j, 5 - j).map(\n            (i2) =>\n              (matrix[y - 2 + j][x - 2 + i2] =\n                matrix[y + 2 - j][x - 2 + i2] =\n                matrix[y - 2 + i2][x - 2 + j] =\n                matrix[y - 2 + i2][x + 2 - j] =\n                  j % 2 === 0),\n          ),\n        ),\n      ),\n  );\nlet getPatternMatrix = (config) => {\n  let patternMatrix = createMatrix(config.dimensions);\n  applyFinderPatterns(patternMatrix);\n  applyAlignmentPatterns(patternMatrix, config.alignmentPattern);\n  applyReservedAreas(patternMatrix, config.version);\n  applyTimingPatterns(patternMatrix);\n  applyDarkModule(patternMatrix);\n  return patternMatrix;\n};\nlet exponents = {};\nlet logs = { 1: 0 };\nrange0(255).reduce(\n  (acc, i) => (\n    (logs[(exponents[i] = acc)] = i), acc & 128 ? (acc * 2) ^ 285 : acc * 2\n  ),\n  1,\n);\nlet mul = (x, y) => (x * y === 0 ? 0 : exponents[(logs[x] + logs[y]) % 255]);\nlet result$1;\nlet mulPoly = (poly1, poly2) => (\n  (result$1 = []),\n  poly1.map((p1, j) => poly2.map((p2, i) => (result$1[j + i] ^= mul(p2, p1)))),\n  result$1\n);\nlet divPoly = (dividend, divisor) => {\n  result$1 = dividend.slice();\n  range0(len(dividend) - len(divisor) + 1).map((i) =>\n    range(1, len(divisor)).map(\n      (j) => (result$1[i + j] ^= mul(divisor[j], result$1[i])),\n    ),\n  );\n  return result$1.slice(len(result$1) - len(divisor) + 1);\n};\nlet generatorPoly = (n) =>\n  range0(n).reduce((acc, i) => mulPoly(acc, [1, exponents[i]]), [1]);\nlet applyFormatInformation = (ecLevel, mask, matrix) => {\n  let bits = chunkString(\"01001110\", 2)[ecLevel] + numToBits(mask, 3);\n  let formatInfo = numToBits(\n    parseInt(\n      bits +\n        pad0(\n          10,\n          divPoly(\n            bitsToArray(bits + pad0(10)),\n            bitsToArray(\"10100110111\"),\n          ).join(\"\"),\n        ),\n      2,\n    ) ^ 21522,\n    15,\n  );\n  let a = 0,\n    b = 0;\n  [range0(8 + 1), range(len(matrix) - 7, len(matrix))]\n    .flat()\n    .map((h, i, arr) => {\n      let v = arr[arr.length - 1 - i];\n      if (h !== 6) matrix[8][h] = formatInfo[a++] === \"1\";\n      if (v !== 6 && v !== len(matrix) - 8)\n        matrix[v][8] = formatInfo[b++] === \"1\";\n    });\n  return matrix;\n};\nlet applyVerisonInformation = (version, matrix) => {\n  if (version < 7) return matrix;\n  let bits = numToBits(version, 6);\n  let versionInfo =\n    bits +\n    pad0(\n      12,\n      divPoly(bitsToArray(bits + pad0(12)), bitsToArray(\"1111100100101\")).join(\n        \"\",\n      ),\n    );\n  let d = 0;\n  range0(6).map((x) =>\n    range0(3).map(\n      (y) =>\n        (matrix[matrix.length - 9 - y][5 - x] = matrix[5 - x][\n          len(matrix) - 9 - y\n        ] =\n          versionInfo[d++] === \"1\"),\n    ),\n  );\n  return matrix;\n};\nlet applyData = (patternMatrix, data) => {\n  let dataMatrix = createMatrix(len(patternMatrix)),\n    MAX = len(patternMatrix) - 1,\n    x = MAX,\n    y = MAX,\n    dx = 0,\n    d = 0,\n    direction = -1;\n  while (d < len(data)) {\n    patternMatrix[y][x - dx] === null &&\n      (dataMatrix[y][x - dx] = data[d++] === \"1\");\n    if (dx === 1) {\n      y += direction;\n      if (y < 0 || y > MAX) {\n        y = (MAX + MAX * direction) / 2;\n        direction *= -1;\n        x -= 2;\n      }\n    }\n    dx ^= 1;\n    x >= 6 && x <= 7 && (x = 5);\n  }\n  return dataMatrix;\n};\nlet place = (config, data) => {\n  let patternMatrix = getPatternMatrix(config);\n  let dataMatrix = applyData(patternMatrix, data);\n  let { mask, matrix } = applyMasking(patternMatrix, dataMatrix);\n  applyFormatInformation(config.ecLevel, mask, matrix);\n  return applyVerisonInformation(config.version, matrix);\n};\nlet getEcWords = (message, ecCodeWordsCount) =>\n  divPoly(\n    message.concat(range0(ecCodeWordsCount).map((_) => 0)),\n    generatorPoly(ecCodeWordsCount),\n  );\nlet encodeSymbols = (content) =>\n  encodeUtf8(content)\n    .map((el) => numToBits(el, 8))\n    .join(\"\");\nlet currentElement;\nlet createBlocks = (config, encodedData) => (\n  (currentElement = 0),\n  config.groups\n    .map((group) =>\n      range0(group.blocks).map((i) =>\n        range0(group.wordsPerBlock).map((j) => encodedData[currentElement++]),\n      ),\n    )\n    .flat()\n);\nlet result;\nlet interleave = (blocks2) => (\n  (result = []),\n  range0(len(blocks2)).map((j) =>\n    range0(len(blocks2[j])).map(\n      (i) => (result[i * len(blocks2) + j] = blocks2[j][i]),\n    ),\n  ),\n  result\n);\nlet blocks;\nlet encode = (config, content) => (\n  (blocks = createBlocks(\n    config,\n    chunkString(\n      fillUpBits(\n        config.requiredNumberOfBits,\n        \"0100\" +\n          numToBits(len(content), config.characterCountBits) +\n          encodeSymbols(content),\n      ),\n      8,\n    ).map((el) => parseInt(el, 2)),\n  )),\n  [\n    interleave(blocks),\n    interleave(blocks.map((b) => getEcWords(b, config.groups[0].ecPerBlock))),\n  ]\n    .flat()\n    .map((uint) => numToBits(uint, 8))\n    .join(\"\") + pad0(config.remainderBits)\n);\nlet fillUpBits = (requiredNumberOfBits2, bits) => {\n  bits += pad0(\n    requiredNumberOfBits2 - len(bits) < 4\n      ? requiredNumberOfBits2 - len(bits)\n      : 4,\n  );\n  bits += pad0(8 - (len(bits) % 8));\n  return bits\n    .padEnd(requiredNumberOfBits2, \"1110110000010001\")\n    .substr(0, requiredNumberOfBits2);\n};\nwindow.QRCodeGetMatrix = (content, ecLevel = EcLevels.L) => {\n  let config = getParameters(content, ecLevel);\n  return place(config, encode(config, content));\n};\nwindow.QRCodeRender = (matrix, color = \"#000\") => {\n  let { d, dim } = renderPath(matrix);\n  return `<svg viewBox=\"0 0 ${dim} ${dim}\" stroke=${color} stroke-width=1.05 xmlns=http://www.w3.org/2000/svg><path d=\"${d}\"/></svg>`;\n};\nlet renderPath = (matrix) => {\n  let d = \"\";\n  matrix.map((row, y) => {\n    let lastX = 0,\n      x = 0,\n      len2;\n    d += `M${5} ${y + 5}`;\n    for (; x < matrix.length; x++) {\n      if (row[x]) {\n        len2 = 0;\n        while (row[++len2 + x]);\n        d += `m${x - lastX} 0h${len2}`;\n        lastX = (x += len2 - 1) + 1;\n      }\n    }\n  });\n  return { d, dim: matrix.length + 10 };\n};\n","./plugins/qrcode/qrcode.js":"window.slidesk.qrcode = () => {\n  document.getElementById(\"sd-qrcode\").innerHTML = window.QRCodeRender(\n    window.QRCodeGetMatrix(window.location.href),\n    \"#000\",\n  );\n};\n"},"addStyles":{"./plugins/qrcode/qrcode.css":"#sd-qrcode {\n  position: absolute;\n  bottom: 10px;\n  left: 10px;\n  background: white;\n}\n\n#sd-qrcode svg {\n  width: 128px;\n}\n"}},"steps":{"onSlideChange":"window.slidesk.prepareSteps();","addScripts":{"./plugins/steps/steps.js":"window.slidesk.oldNext = window.slidesk.next;\n\nconst checkStepConditions = () =>\n  [...window.slidesk.slides[window.slidesk.currentSlide].classList].includes(\n    \"steps\",\n  ) && window.slidesk.lastAction === \"next\";\n\nwindow.slidesk.prepareSteps = () => {\n  if (checkStepConditions()) {\n    window.slidesk.step = 0;\n    window.slidesk.$lis =\n      window.slidesk.slides[window.slidesk.currentSlide].querySelectorAll(\n        \"ul li\",\n      );\n    window.slidesk.maxSteps = window.slidesk.$lis.length;\n    [...window.slidesk.$lis].forEach((li) => li.classList.remove(\"step-shown\"));\n  }\n};\n\nwindow.slidesk.next = () => {\n  if (checkStepConditions()) {\n    if (window.slidesk.step === window.slidesk.maxSteps) {\n      window.slidesk.oldNext();\n    } else {\n      window.slidesk.$lis[window.slidesk.step++].classList.add(\"step-shown\");\n    }\n  } else window.slidesk.oldNext();\n};\n"},"addStyles":{"./plugins/steps/steps.css":":root {\n  --animationSteps: var(--animationTimer);\n}\n\n.steps li {\n  opacity: 0;\n  transition: opacity var(--animationSteps);\n}\n\n.steps li.step-shown {\n  opacity: 1;\n}\n"}}}